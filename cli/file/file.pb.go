// Code generated by protoc-gen-go.
// source: file.proto
// DO NOT EDIT!

package file

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TransferCommand int32

const (
	TransferCommand_INIT  TransferCommand = 0
	TransferCommand_PAUSE TransferCommand = 1
	TransferCommand_CLOSE TransferCommand = 2
)

var TransferCommand_name = map[int32]string{
	0: "INIT",
	1: "PAUSE",
	2: "CLOSE",
}
var TransferCommand_value = map[string]int32{
	"INIT":  0,
	"PAUSE": 1,
	"CLOSE": 2,
}

func (x TransferCommand) String() string {
	return proto.EnumName(TransferCommand_name, int32(x))
}
func (TransferCommand) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type FileStore struct {
	Name             string          `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	TotalSpace       int64           `protobuf:"varint,2,opt,name=total_space,json=totalSpace" json:"total_space,omitempty"`
	UnallocatedSpace int64           `protobuf:"varint,3,opt,name=unallocated_space,json=unallocatedSpace" json:"unallocated_space,omitempty"`
	UsableSpace      int64           `protobuf:"varint,4,opt,name=usable_space,json=usableSpace" json:"usable_space,omitempty"`
	Url              *FileStoreURL   `protobuf:"bytes,5,opt,name=url" json:"url,omitempty"`
	Extra            *FileStoreExtra `protobuf:"bytes,6,opt,name=extra" json:"extra,omitempty"`
}

func (m *FileStore) Reset()                    { *m = FileStore{} }
func (m *FileStore) String() string            { return proto.CompactTextString(m) }
func (*FileStore) ProtoMessage()               {}
func (*FileStore) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *FileStore) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileStore) GetTotalSpace() int64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *FileStore) GetUnallocatedSpace() int64 {
	if m != nil {
		return m.UnallocatedSpace
	}
	return 0
}

func (m *FileStore) GetUsableSpace() int64 {
	if m != nil {
		return m.UsableSpace
	}
	return 0
}

func (m *FileStore) GetUrl() *FileStoreURL {
	if m != nil {
		return m.Url
	}
	return nil
}

func (m *FileStore) GetExtra() *FileStoreExtra {
	if m != nil {
		return m.Extra
	}
	return nil
}

type FileStoreURL struct {
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *FileStoreURL) Reset()                    { *m = FileStoreURL{} }
func (m *FileStoreURL) String() string            { return proto.CompactTextString(m) }
func (*FileStoreURL) ProtoMessage()               {}
func (*FileStoreURL) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *FileStoreURL) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *FileStoreURL) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type FileStoreExtra struct {
}

func (m *FileStoreExtra) Reset()                    { *m = FileStoreExtra{} }
func (m *FileStoreExtra) String() string            { return proto.CompactTextString(m) }
func (*FileStoreExtra) ProtoMessage()               {}
func (*FileStoreExtra) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type Path struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *Path) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type File struct {
	FileStoreUrl *FileStoreURL `protobuf:"bytes,100,opt,name=file_store_url,json=fileStoreUrl" json:"file_store_url,omitempty"`
	Name         string        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Path         *Path         `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Size         int64         `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	Checksum     []byte        `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	Uuid         string        `protobuf:"bytes,5,opt,name=uuid" json:"uuid,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *File) GetFileStoreUrl() *FileStoreURL {
	if m != nil {
		return m.FileStoreUrl
	}
	return nil
}

func (m *File) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *File) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *File) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *File) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *File) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

type FileBlock struct {
	Block []byte `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *FileBlock) Reset()                    { *m = FileBlock{} }
func (m *FileBlock) String() string            { return proto.CompactTextString(m) }
func (*FileBlock) ProtoMessage()               {}
func (*FileBlock) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *FileBlock) GetBlock() []byte {
	if m != nil {
		return m.Block
	}
	return nil
}

type Token struct {
	Token []byte `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *Token) Reset()                    { *m = Token{} }
func (m *Token) String() string            { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()               {}
func (*Token) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *Token) GetToken() []byte {
	if m != nil {
		return m.Token
	}
	return nil
}

type ListResponse struct {
	Error *FileSystemError `protobuf:"bytes,100,opt,name=error" json:"error,omitempty"`
	Name  []string         `protobuf:"bytes,1,rep,name=name" json:"name,omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *ListResponse) GetError() *FileSystemError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ListResponse) GetName() []string {
	if m != nil {
		return m.Name
	}
	return nil
}

type CopyRequest struct {
	Src  *Path `protobuf:"bytes,1,opt,name=src" json:"src,omitempty"`
	Dest *Path `protobuf:"bytes,2,opt,name=dest" json:"dest,omitempty"`
}

func (m *CopyRequest) Reset()                    { *m = CopyRequest{} }
func (m *CopyRequest) String() string            { return proto.CompactTextString(m) }
func (*CopyRequest) ProtoMessage()               {}
func (*CopyRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *CopyRequest) GetSrc() *Path {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *CopyRequest) GetDest() *Path {
	if m != nil {
		return m.Dest
	}
	return nil
}

type CopyResponse struct {
	Error *FileSystemError `protobuf:"bytes,100,opt,name=error" json:"error,omitempty"`
}

func (m *CopyResponse) Reset()                    { *m = CopyResponse{} }
func (m *CopyResponse) String() string            { return proto.CompactTextString(m) }
func (*CopyResponse) ProtoMessage()               {}
func (*CopyResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *CopyResponse) GetError() *FileSystemError {
	if m != nil {
		return m.Error
	}
	return nil
}

type MoveRequest struct {
	Src  *Path `protobuf:"bytes,1,opt,name=src" json:"src,omitempty"`
	Dest *Path `protobuf:"bytes,2,opt,name=dest" json:"dest,omitempty"`
}

func (m *MoveRequest) Reset()                    { *m = MoveRequest{} }
func (m *MoveRequest) String() string            { return proto.CompactTextString(m) }
func (*MoveRequest) ProtoMessage()               {}
func (*MoveRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *MoveRequest) GetSrc() *Path {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *MoveRequest) GetDest() *Path {
	if m != nil {
		return m.Dest
	}
	return nil
}

type MoveResponse struct {
	Error *FileSystemError `protobuf:"bytes,100,opt,name=error" json:"error,omitempty"`
}

func (m *MoveResponse) Reset()                    { *m = MoveResponse{} }
func (m *MoveResponse) String() string            { return proto.CompactTextString(m) }
func (*MoveResponse) ProtoMessage()               {}
func (*MoveResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *MoveResponse) GetError() *FileSystemError {
	if m != nil {
		return m.Error
	}
	return nil
}

type DeleteResponse struct {
	Error *FileSystemError `protobuf:"bytes,100,opt,name=error" json:"error,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

func (m *DeleteResponse) GetError() *FileSystemError {
	if m != nil {
		return m.Error
	}
	return nil
}

type CreateDirectoryResponse struct {
	Error *FileSystemError `protobuf:"bytes,100,opt,name=error" json:"error,omitempty"`
}

func (m *CreateDirectoryResponse) Reset()                    { *m = CreateDirectoryResponse{} }
func (m *CreateDirectoryResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateDirectoryResponse) ProtoMessage()               {}
func (*CreateDirectoryResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

func (m *CreateDirectoryResponse) GetError() *FileSystemError {
	if m != nil {
		return m.Error
	}
	return nil
}

type CreateFileMetaResponse struct {
	Error *FileSystemError `protobuf:"bytes,100,opt,name=error" json:"error,omitempty"`
	File  *File            `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
}

func (m *CreateFileMetaResponse) Reset()                    { *m = CreateFileMetaResponse{} }
func (m *CreateFileMetaResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateFileMetaResponse) ProtoMessage()               {}
func (*CreateFileMetaResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

func (m *CreateFileMetaResponse) GetError() *FileSystemError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CreateFileMetaResponse) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type GetFileMetaResponse struct {
	Error *FileSystemError `protobuf:"bytes,100,opt,name=error" json:"error,omitempty"`
	File  *File            `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
}

func (m *GetFileMetaResponse) Reset()                    { *m = GetFileMetaResponse{} }
func (m *GetFileMetaResponse) String() string            { return proto.CompactTextString(m) }
func (*GetFileMetaResponse) ProtoMessage()               {}
func (*GetFileMetaResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *GetFileMetaResponse) GetError() *FileSystemError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetFileMetaResponse) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type PutFileResponse struct {
	Command TransferCommand `protobuf:"varint,100,opt,name=command,enum=file.TransferCommand" json:"command,omitempty"`
}

func (m *PutFileResponse) Reset()                    { *m = PutFileResponse{} }
func (m *PutFileResponse) String() string            { return proto.CompactTextString(m) }
func (*PutFileResponse) ProtoMessage()               {}
func (*PutFileResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{16} }

func (m *PutFileResponse) GetCommand() TransferCommand {
	if m != nil {
		return m.Command
	}
	return TransferCommand_INIT
}

type GetFileRequest struct {
	Command TransferCommand `protobuf:"varint,100,opt,name=command,enum=file.TransferCommand" json:"command,omitempty"`
	Token   *Token          `protobuf:"bytes,99,opt,name=token" json:"token,omitempty"`
	Uuid    []byte          `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *GetFileRequest) Reset()                    { *m = GetFileRequest{} }
func (m *GetFileRequest) String() string            { return proto.CompactTextString(m) }
func (*GetFileRequest) ProtoMessage()               {}
func (*GetFileRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{17} }

func (m *GetFileRequest) GetCommand() TransferCommand {
	if m != nil {
		return m.Command
	}
	return TransferCommand_INIT
}

func (m *GetFileRequest) GetToken() *Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *GetFileRequest) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type ControlledPacket struct {
	// Types that are valid to be assigned to Data:
	//	*ControlledPacket_FileToChap
	//	*ControlledPacket_FileBlock
	//	*ControlledPacket_Command
	Data isControlledPacket_Data `protobuf_oneof:"data"`
}

func (m *ControlledPacket) Reset()                    { *m = ControlledPacket{} }
func (m *ControlledPacket) String() string            { return proto.CompactTextString(m) }
func (*ControlledPacket) ProtoMessage()               {}
func (*ControlledPacket) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{18} }

type isControlledPacket_Data interface {
	isControlledPacket_Data()
}

type ControlledPacket_FileToChap struct {
	FileToChap *File `protobuf:"bytes,1,opt,name=file_to_chap,json=fileToChap,oneof"`
}
type ControlledPacket_FileBlock struct {
	FileBlock *FileBlock `protobuf:"bytes,2,opt,name=file_block,json=fileBlock,oneof"`
}
type ControlledPacket_Command struct {
	Command TransferCommand `protobuf:"varint,3,opt,name=command,enum=file.TransferCommand,oneof"`
}

func (*ControlledPacket_FileToChap) isControlledPacket_Data() {}
func (*ControlledPacket_FileBlock) isControlledPacket_Data()  {}
func (*ControlledPacket_Command) isControlledPacket_Data()    {}

func (m *ControlledPacket) GetData() isControlledPacket_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ControlledPacket) GetFileToChap() *File {
	if x, ok := m.GetData().(*ControlledPacket_FileToChap); ok {
		return x.FileToChap
	}
	return nil
}

func (m *ControlledPacket) GetFileBlock() *FileBlock {
	if x, ok := m.GetData().(*ControlledPacket_FileBlock); ok {
		return x.FileBlock
	}
	return nil
}

func (m *ControlledPacket) GetCommand() TransferCommand {
	if x, ok := m.GetData().(*ControlledPacket_Command); ok {
		return x.Command
	}
	return TransferCommand_INIT
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ControlledPacket) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ControlledPacket_OneofMarshaler, _ControlledPacket_OneofUnmarshaler, _ControlledPacket_OneofSizer, []interface{}{
		(*ControlledPacket_FileToChap)(nil),
		(*ControlledPacket_FileBlock)(nil),
		(*ControlledPacket_Command)(nil),
	}
}

func _ControlledPacket_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ControlledPacket)
	// data
	switch x := m.Data.(type) {
	case *ControlledPacket_FileToChap:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileToChap); err != nil {
			return err
		}
	case *ControlledPacket_FileBlock:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileBlock); err != nil {
			return err
		}
	case *ControlledPacket_Command:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Command))
	case nil:
	default:
		return fmt.Errorf("ControlledPacket.Data has unexpected type %T", x)
	}
	return nil
}

func _ControlledPacket_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ControlledPacket)
	switch tag {
	case 1: // data.file_to_chap
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(File)
		err := b.DecodeMessage(msg)
		m.Data = &ControlledPacket_FileToChap{msg}
		return true, err
	case 2: // data.file_block
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileBlock)
		err := b.DecodeMessage(msg)
		m.Data = &ControlledPacket_FileBlock{msg}
		return true, err
	case 3: // data.command
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Data = &ControlledPacket_Command{TransferCommand(x)}
		return true, err
	default:
		return false, nil
	}
}

func _ControlledPacket_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ControlledPacket)
	// data
	switch x := m.Data.(type) {
	case *ControlledPacket_FileToChap:
		s := proto.Size(x.FileToChap)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ControlledPacket_FileBlock:
		s := proto.Size(x.FileBlock)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ControlledPacket_Command:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Command))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*FileStore)(nil), "file.FileStore")
	proto.RegisterType((*FileStoreURL)(nil), "file.FileStoreURL")
	proto.RegisterType((*FileStoreExtra)(nil), "file.FileStoreExtra")
	proto.RegisterType((*Path)(nil), "file.Path")
	proto.RegisterType((*File)(nil), "file.File")
	proto.RegisterType((*FileBlock)(nil), "file.FileBlock")
	proto.RegisterType((*Token)(nil), "file.Token")
	proto.RegisterType((*ListResponse)(nil), "file.ListResponse")
	proto.RegisterType((*CopyRequest)(nil), "file.CopyRequest")
	proto.RegisterType((*CopyResponse)(nil), "file.CopyResponse")
	proto.RegisterType((*MoveRequest)(nil), "file.MoveRequest")
	proto.RegisterType((*MoveResponse)(nil), "file.MoveResponse")
	proto.RegisterType((*DeleteResponse)(nil), "file.DeleteResponse")
	proto.RegisterType((*CreateDirectoryResponse)(nil), "file.CreateDirectoryResponse")
	proto.RegisterType((*CreateFileMetaResponse)(nil), "file.CreateFileMetaResponse")
	proto.RegisterType((*GetFileMetaResponse)(nil), "file.GetFileMetaResponse")
	proto.RegisterType((*PutFileResponse)(nil), "file.PutFileResponse")
	proto.RegisterType((*GetFileRequest)(nil), "file.GetFileRequest")
	proto.RegisterType((*ControlledPacket)(nil), "file.ControlledPacket")
	proto.RegisterEnum("file.TransferCommand", TransferCommand_name, TransferCommand_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FileSystem service

type FileSystemClient interface {
	List(ctx context.Context, in *Path, opts ...grpc.CallOption) (*ListResponse, error)
	Copy(ctx context.Context, in *CopyRequest, opts ...grpc.CallOption) (*CopyResponse, error)
	CreateDirectory(ctx context.Context, in *Path, opts ...grpc.CallOption) (*CreateDirectoryResponse, error)
	Delete(ctx context.Context, in *Path, opts ...grpc.CallOption) (*DeleteResponse, error)
	DeleteIfExists(ctx context.Context, in *Path, opts ...grpc.CallOption) (*DeleteResponse, error)
	Move(ctx context.Context, in *MoveRequest, opts ...grpc.CallOption) (*MoveResponse, error)
	CreateFileMeta(ctx context.Context, in *File, opts ...grpc.CallOption) (*CreateFileMetaResponse, error)
	GetFileMeta(ctx context.Context, in *Path, opts ...grpc.CallOption) (*GetFileMetaResponse, error)
	RequestAccessToken(ctx context.Context, in *Path, opts ...grpc.CallOption) (*Token, error)
}

type fileSystemClient struct {
	cc *grpc.ClientConn
}

func NewFileSystemClient(cc *grpc.ClientConn) FileSystemClient {
	return &fileSystemClient{cc}
}

func (c *fileSystemClient) List(ctx context.Context, in *Path, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) Copy(ctx context.Context, in *CopyRequest, opts ...grpc.CallOption) (*CopyResponse, error) {
	out := new(CopyResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/Copy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) CreateDirectory(ctx context.Context, in *Path, opts ...grpc.CallOption) (*CreateDirectoryResponse, error) {
	out := new(CreateDirectoryResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/CreateDirectory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) Delete(ctx context.Context, in *Path, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) DeleteIfExists(ctx context.Context, in *Path, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/DeleteIfExists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) Move(ctx context.Context, in *MoveRequest, opts ...grpc.CallOption) (*MoveResponse, error) {
	out := new(MoveResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/Move", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) CreateFileMeta(ctx context.Context, in *File, opts ...grpc.CallOption) (*CreateFileMetaResponse, error) {
	out := new(CreateFileMetaResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/CreateFileMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) GetFileMeta(ctx context.Context, in *Path, opts ...grpc.CallOption) (*GetFileMetaResponse, error) {
	out := new(GetFileMetaResponse)
	err := grpc.Invoke(ctx, "/file.FileSystem/GetFileMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSystemClient) RequestAccessToken(ctx context.Context, in *Path, opts ...grpc.CallOption) (*Token, error) {
	out := new(Token)
	err := grpc.Invoke(ctx, "/file.FileSystem/RequestAccessToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileSystem service

type FileSystemServer interface {
	List(context.Context, *Path) (*ListResponse, error)
	Copy(context.Context, *CopyRequest) (*CopyResponse, error)
	CreateDirectory(context.Context, *Path) (*CreateDirectoryResponse, error)
	Delete(context.Context, *Path) (*DeleteResponse, error)
	DeleteIfExists(context.Context, *Path) (*DeleteResponse, error)
	Move(context.Context, *MoveRequest) (*MoveResponse, error)
	CreateFileMeta(context.Context, *File) (*CreateFileMetaResponse, error)
	GetFileMeta(context.Context, *Path) (*GetFileMetaResponse, error)
	RequestAccessToken(context.Context, *Path) (*Token, error)
}

func RegisterFileSystemServer(s *grpc.Server, srv FileSystemServer) {
	s.RegisterService(&_FileSystem_serviceDesc, srv)
}

func _FileSystem_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Path)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).List(ctx, req.(*Path))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_Copy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).Copy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/Copy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).Copy(ctx, req.(*CopyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_CreateDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Path)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/CreateDirectory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateDirectory(ctx, req.(*Path))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Path)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).Delete(ctx, req.(*Path))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_DeleteIfExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Path)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).DeleteIfExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/DeleteIfExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).DeleteIfExists(ctx, req.(*Path))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/Move",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).Move(ctx, req.(*MoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_CreateFileMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(File)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).CreateFileMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/CreateFileMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).CreateFileMeta(ctx, req.(*File))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_GetFileMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Path)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).GetFileMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/GetFileMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).GetFileMeta(ctx, req.(*Path))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSystem_RequestAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Path)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSystemServer).RequestAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/file.FileSystem/RequestAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSystemServer).RequestAccessToken(ctx, req.(*Path))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileSystem_serviceDesc = grpc.ServiceDesc{
	ServiceName: "file.FileSystem",
	HandlerType: (*FileSystemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _FileSystem_List_Handler,
		},
		{
			MethodName: "Copy",
			Handler:    _FileSystem_Copy_Handler,
		},
		{
			MethodName: "CreateDirectory",
			Handler:    _FileSystem_CreateDirectory_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FileSystem_Delete_Handler,
		},
		{
			MethodName: "DeleteIfExists",
			Handler:    _FileSystem_DeleteIfExists_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _FileSystem_Move_Handler,
		},
		{
			MethodName: "CreateFileMeta",
			Handler:    _FileSystem_CreateFileMeta_Handler,
		},
		{
			MethodName: "GetFileMeta",
			Handler:    _FileSystem_GetFileMeta_Handler,
		},
		{
			MethodName: "RequestAccessToken",
			Handler:    _FileSystem_RequestAccessToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "file.proto",
}

// Client API for FileStoreDevice service

type FileStoreDeviceClient interface {
	PutFile(ctx context.Context, opts ...grpc.CallOption) (FileStoreDevice_PutFileClient, error)
	GetFile(ctx context.Context, opts ...grpc.CallOption) (FileStoreDevice_GetFileClient, error)
}

type fileStoreDeviceClient struct {
	cc *grpc.ClientConn
}

func NewFileStoreDeviceClient(cc *grpc.ClientConn) FileStoreDeviceClient {
	return &fileStoreDeviceClient{cc}
}

func (c *fileStoreDeviceClient) PutFile(ctx context.Context, opts ...grpc.CallOption) (FileStoreDevice_PutFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileStoreDevice_serviceDesc.Streams[0], c.cc, "/file.FileStoreDevice/PutFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileStoreDevicePutFileClient{stream}
	return x, nil
}

type FileStoreDevice_PutFileClient interface {
	Send(*ControlledPacket) error
	Recv() (*PutFileResponse, error)
	grpc.ClientStream
}

type fileStoreDevicePutFileClient struct {
	grpc.ClientStream
}

func (x *fileStoreDevicePutFileClient) Send(m *ControlledPacket) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileStoreDevicePutFileClient) Recv() (*PutFileResponse, error) {
	m := new(PutFileResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileStoreDeviceClient) GetFile(ctx context.Context, opts ...grpc.CallOption) (FileStoreDevice_GetFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileStoreDevice_serviceDesc.Streams[1], c.cc, "/file.FileStoreDevice/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileStoreDeviceGetFileClient{stream}
	return x, nil
}

type FileStoreDevice_GetFileClient interface {
	Send(*GetFileRequest) error
	Recv() (*ControlledPacket, error)
	grpc.ClientStream
}

type fileStoreDeviceGetFileClient struct {
	grpc.ClientStream
}

func (x *fileStoreDeviceGetFileClient) Send(m *GetFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileStoreDeviceGetFileClient) Recv() (*ControlledPacket, error) {
	m := new(ControlledPacket)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FileStoreDevice service

type FileStoreDeviceServer interface {
	PutFile(FileStoreDevice_PutFileServer) error
	GetFile(FileStoreDevice_GetFileServer) error
}

func RegisterFileStoreDeviceServer(s *grpc.Server, srv FileStoreDeviceServer) {
	s.RegisterService(&_FileStoreDevice_serviceDesc, srv)
}

func _FileStoreDevice_PutFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileStoreDeviceServer).PutFile(&fileStoreDevicePutFileServer{stream})
}

type FileStoreDevice_PutFileServer interface {
	Send(*PutFileResponse) error
	Recv() (*ControlledPacket, error)
	grpc.ServerStream
}

type fileStoreDevicePutFileServer struct {
	grpc.ServerStream
}

func (x *fileStoreDevicePutFileServer) Send(m *PutFileResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileStoreDevicePutFileServer) Recv() (*ControlledPacket, error) {
	m := new(ControlledPacket)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FileStoreDevice_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileStoreDeviceServer).GetFile(&fileStoreDeviceGetFileServer{stream})
}

type FileStoreDevice_GetFileServer interface {
	Send(*ControlledPacket) error
	Recv() (*GetFileRequest, error)
	grpc.ServerStream
}

type fileStoreDeviceGetFileServer struct {
	grpc.ServerStream
}

func (x *fileStoreDeviceGetFileServer) Send(m *ControlledPacket) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileStoreDeviceGetFileServer) Recv() (*GetFileRequest, error) {
	m := new(GetFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _FileStoreDevice_serviceDesc = grpc.ServiceDesc{
	ServiceName: "file.FileStoreDevice",
	HandlerType: (*FileStoreDeviceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutFile",
			Handler:       _FileStoreDevice_PutFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _FileStoreDevice_GetFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "file.proto",
}

func init() { proto.RegisterFile("file.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 893 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x56, 0xe1, 0x6e, 0x1b, 0x45,
	0x10, 0xbe, 0x8b, 0xcf, 0x49, 0x3c, 0xb6, 0x6c, 0x77, 0x09, 0x6d, 0xb0, 0xda, 0x92, 0xac, 0xf8,
	0x61, 0x15, 0x94, 0xb4, 0x01, 0x55, 0x48, 0xd0, 0x4a, 0xb5, 0xe3, 0x92, 0x88, 0x94, 0x5a, 0x9b,
	0xf4, 0xb7, 0xb5, 0x39, 0x8f, 0x65, 0x2b, 0x67, 0xaf, 0xd9, 0x5d, 0x57, 0x29, 0x4f, 0xc1, 0x9b,
	0xf0, 0x97, 0xe7, 0x81, 0x17, 0x41, 0xb3, 0x7b, 0xe7, 0xdc, 0x99, 0x04, 0x81, 0x45, 0xff, 0xcd,
	0xce, 0x7c, 0x33, 0x3b, 0x33, 0x37, 0xdf, 0xec, 0x01, 0x8c, 0x26, 0x09, 0x1e, 0xcc, 0xb5, 0xb2,
	0x8a, 0x45, 0x24, 0xb7, 0x6a, 0xa8, 0xb5, 0xd2, 0xc6, 0xeb, 0xf8, 0x1f, 0x21, 0x54, 0x5e, 0x4f,
	0x12, 0x3c, 0xb7, 0x4a, 0x23, 0x63, 0x10, 0xcd, 0xe4, 0x14, 0x77, 0xc3, 0xbd, 0xb0, 0x5d, 0x11,
	0x4e, 0x66, 0x9f, 0x43, 0xd5, 0x2a, 0x2b, 0x93, 0x81, 0x99, 0xcb, 0x18, 0x77, 0x37, 0xf6, 0xc2,
	0x76, 0x49, 0x80, 0x53, 0x9d, 0x93, 0x86, 0x7d, 0x09, 0xf7, 0x16, 0x33, 0x99, 0x24, 0x2a, 0x96,
	0x16, 0x87, 0x29, 0xac, 0xe4, 0x60, 0xcd, 0x9c, 0xc1, 0x83, 0xf7, 0xa1, 0xb6, 0x30, 0xf2, 0x32,
	0xc1, 0x14, 0x17, 0x39, 0x5c, 0xd5, 0xeb, 0x3c, 0xe4, 0x0b, 0x28, 0x2d, 0x74, 0xb2, 0x5b, 0xde,
	0x0b, 0xdb, 0xd5, 0x23, 0x76, 0xe0, 0x0a, 0x58, 0xa6, 0xf8, 0x4e, 0x9c, 0x09, 0x32, 0xb3, 0x27,
	0x50, 0xc6, 0x6b, 0xab, 0xe5, 0xee, 0xa6, 0xc3, 0xed, 0xac, 0xe0, 0x7a, 0x64, 0x13, 0x1e, 0xc2,
	0x9f, 0x43, 0x2d, 0x1f, 0x80, 0xca, 0x1c, 0x2b, 0x63, 0xb3, 0x32, 0x49, 0x26, 0xdd, 0x5c, 0x69,
	0xeb, 0xea, 0x2b, 0x0b, 0x27, 0xf3, 0x26, 0xd4, 0x8b, 0x01, 0x79, 0x0b, 0xa2, 0xbe, 0xb4, 0x63,
	0x87, 0x96, 0x76, 0x9c, 0x45, 0x20, 0x99, 0xff, 0x1e, 0x42, 0x44, 0x70, 0xf6, 0x2d, 0xd4, 0x29,
	0x99, 0x81, 0x21, 0xbf, 0x01, 0xd5, 0x32, 0xbc, 0xb3, 0x96, 0xda, 0x68, 0x79, 0xd2, 0xc9, 0xad,
	0xfd, 0x7f, 0x9c, 0x5e, 0xb5, 0xe1, 0x62, 0x80, 0x8f, 0x41, 0x49, 0xf8, 0x6b, 0xc9, 0xc7, 0x4c,
	0x7e, 0xc9, 0x3a, 0xee, 0x64, 0xd6, 0x82, 0xed, 0x78, 0x8c, 0xf1, 0x95, 0x59, 0x4c, 0x5d, 0x87,
	0x6b, 0x62, 0x79, 0x26, 0xfc, 0x62, 0x31, 0x19, 0xba, 0xfe, 0x56, 0x84, 0x93, 0xf9, 0xbe, 0x1f,
	0x82, 0x4e, 0xa2, 0xe2, 0x2b, 0xb6, 0x03, 0xe5, 0x4b, 0x12, 0x5c, 0x16, 0x35, 0xe1, 0x0f, 0xfc,
	0x11, 0x94, 0x2f, 0xd4, 0x15, 0xce, 0xc8, 0x6c, 0x49, 0xc8, 0xcc, 0xee, 0xc0, 0xdf, 0x42, 0xed,
	0x6c, 0x62, 0xac, 0x40, 0x33, 0x57, 0x33, 0x43, 0x43, 0x51, 0x76, 0x73, 0x96, 0x96, 0xfe, 0x69,
	0xae, 0xf4, 0x0f, 0xc6, 0xe2, 0xb4, 0x47, 0x46, 0xe1, 0x31, 0xb9, 0xb2, 0x4b, 0x59, 0xd9, 0xfc,
	0x47, 0xa8, 0x76, 0xd5, 0xfc, 0x83, 0xc0, 0x9f, 0x17, 0x68, 0x2c, 0x7b, 0x08, 0x25, 0xa3, 0x63,
	0x77, 0x67, 0xb1, 0x09, 0xa4, 0xa6, 0x1e, 0x0d, 0xd1, 0xd8, 0xdb, 0x7a, 0x44, 0x7a, 0xfe, 0x1d,
	0xd4, 0x7c, 0xb0, 0x35, 0xb2, 0xa3, 0x4c, 0xde, 0xa8, 0xf7, 0xf8, 0xbf, 0x65, 0xe2, 0x83, 0xad,
	0x93, 0xc9, 0x0b, 0xa8, 0x1f, 0x63, 0x82, 0x76, 0x4d, 0xf7, 0xd7, 0xf0, 0xa0, 0xab, 0x51, 0x5a,
	0x3c, 0x9e, 0x68, 0x8c, 0xad, 0xd2, 0x6b, 0x36, 0x04, 0xe1, 0xbe, 0x8f, 0x43, 0xf6, 0x37, 0x68,
	0xe5, 0x7a, 0x5f, 0xfd, 0x31, 0xb8, 0x85, 0x54, 0xec, 0x24, 0x61, 0x85, 0xd3, 0xf3, 0x4b, 0xf8,
	0xe4, 0x07, 0xb4, 0x1f, 0xf7, 0x8e, 0x0e, 0x34, 0xfa, 0x0b, 0x77, 0xc7, 0x32, 0xfe, 0x21, 0x6c,
	0xc5, 0x6a, 0x3a, 0x95, 0xb3, 0xa1, 0xbb, 0xa1, 0x9e, 0xdd, 0x70, 0xa1, 0xe5, 0xcc, 0x8c, 0x50,
	0x77, 0xbd, 0x51, 0x64, 0x28, 0x7e, 0x0d, 0xf5, 0x34, 0xcf, 0x6c, 0x44, 0xfe, 0x6b, 0x08, 0xb6,
	0x9f, 0x71, 0x2a, 0x76, 0x79, 0x56, 0x53, 0x38, 0xa9, 0x52, 0x82, 0x2d, 0x69, 0xbb, 0xe1, 0x58,
	0xe7, 0x69, 0xfb, 0x5b, 0x08, 0xcd, 0xae, 0x9a, 0x59, 0xad, 0x92, 0x04, 0x87, 0x7d, 0x19, 0x5f,
	0xa1, 0x65, 0x07, 0xe0, 0x76, 0xca, 0xc0, 0xaa, 0x41, 0x3c, 0x96, 0xf3, 0xbf, 0x97, 0x7e, 0x12,
	0x08, 0xf7, 0x2a, 0x5c, 0xa8, 0xee, 0x58, 0xce, 0xd9, 0x53, 0xff, 0x46, 0x0c, 0x3c, 0xe7, 0xfd,
	0xdc, 0x36, 0x6e, 0xd0, 0x6e, 0x27, 0x9c, 0x04, 0xa2, 0x32, 0x5a, 0x2e, 0x88, 0x67, 0x37, 0xe5,
	0x95, 0xfe, 0xa1, 0xbc, 0x93, 0x60, 0x59, 0x60, 0x67, 0x13, 0xa2, 0xa1, 0xb4, 0xf2, 0xc9, 0x33,
	0x68, 0xac, 0xa0, 0xd8, 0x36, 0x44, 0xa7, 0x3f, 0x9d, 0x5e, 0x34, 0x03, 0x56, 0x81, 0x72, 0xff,
	0xd5, 0xbb, 0xf3, 0x5e, 0x33, 0x24, 0xb1, 0x7b, 0xf6, 0xf6, 0xbc, 0xd7, 0xdc, 0x38, 0xfa, 0xb3,
	0x04, 0x70, 0xf3, 0x75, 0x59, 0x1b, 0x22, 0x5a, 0x34, 0x2c, 0x47, 0xad, 0x56, 0xba, 0x58, 0xf3,
	0x0b, 0x88, 0x07, 0xec, 0x10, 0x22, 0x22, 0x3d, 0xbb, 0xe7, 0xad, 0xb9, 0x6d, 0x92, 0x39, 0xe4,
	0x77, 0x02, 0x0f, 0xd8, 0x4b, 0x68, 0xac, 0xf0, 0xa3, 0x70, 0xcb, 0xa3, 0xd4, 0xe9, 0x76, 0x0a,
	0xf1, 0x80, 0x7d, 0x05, 0x9b, 0x9e, 0x9e, 0x05, 0xb7, 0xf4, 0x65, 0x2a, 0x12, 0x97, 0x07, 0xec,
	0x9b, 0x8c, 0xcc, 0xa7, 0xa3, 0xde, 0xf5, 0xc4, 0x58, 0xf3, 0xaf, 0xbc, 0x0e, 0x21, 0xa2, 0xfd,
	0x91, 0x15, 0x95, 0x5b, 0x4c, 0x59, 0x51, 0xf9, 0xf5, 0xc2, 0x03, 0xf6, 0x3d, 0xd4, 0x8b, 0x64,
	0x65, 0xb9, 0x51, 0x68, 0x3d, 0xcc, 0xd7, 0xb4, 0x4a, 0x35, 0x1e, 0xb0, 0xe7, 0x50, 0xcd, 0x71,
	0xb0, 0x90, 0xe1, 0x67, 0x5e, 0xbe, 0x85, 0xa2, 0x2e, 0x4d, 0x96, 0xa6, 0xf5, 0x2a, 0x8e, 0xd1,
	0x18, 0xff, 0x74, 0xe4, 0xdd, 0xf3, 0x33, 0xce, 0x83, 0xa3, 0x5f, 0x43, 0x68, 0x2c, 0x1f, 0xc6,
	0x63, 0x7c, 0x3f, 0x89, 0x91, 0xbd, 0x84, 0xad, 0x94, 0x9c, 0xec, 0x7e, 0xf6, 0xc1, 0x8a, 0xc3,
	0xde, 0x4a, 0x27, 0x6f, 0x85, 0xc3, 0x3c, 0x68, 0x87, 0x4f, 0x43, 0xf6, 0x02, 0xb6, 0xd2, 0xec,
	0xd8, 0x4e, 0x21, 0xd9, 0xac, 0x63, 0x77, 0x44, 0xf5, 0xee, 0x9d, 0x07, 0xb0, 0x3d, 0x43, 0xeb,
	0x20, 0x1d, 0xf7, 0x3c, 0xf6, 0xe9, 0x8f, 0xa9, 0x1f, 0x5e, 0x6e, 0xba, 0x5f, 0xa7, 0xaf, 0xff,
	0x0a, 0x00, 0x00, 0xff, 0xff, 0xb1, 0x9f, 0x39, 0x98, 0x5c, 0x09, 0x00, 0x00,
}
